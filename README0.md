# LHCF(Lite HTTP Crawler Framework)轻量级HTTP爬虫框架（暂定）

目前的使用流程为：定义Job，定义Task，定义ResultHandler，设定种子，执行。

本来该项目有设想过应用于Http以外的协议，打算先基于Http开发，后续再加入其他协议，最终实现为一款通用的爬虫框架。但实际开发过程中，为了预留其他协议的扩展空间，反而经常束手束脚，影响了开发效率。因此，现在决定只考虑Http协议，**做一款专门针对Http爬虫框架**。

该框架的另一个目标是**轻量**，主要体现在配置简单与资源占用低上。为了优先实现这一点，将放缓对可扩展性的要求。

## TOC

- [LHCF(Lite HTTP Crawler Framework)轻量级HTTP爬虫框架（暂定）](#lhcflite-http-crawler-framework轻量级http爬虫框架暂定)
  - [TOC](#toc)
  - [需求分析](#需求分析)
  - [Http请求/响应的处理](#http请求响应的处理)
  - [Http请求处理](#http请求处理)
  - [爬虫任务池](#爬虫任务池)
    - [爬虫任务池-基于Java阻塞队列的实现](#爬虫任务池-基于java阻塞队列的实现)
    - [爬虫任务池-基于Redis消息队列的实现](#爬虫任务池-基于redis消息队列的实现)
  - [爬虫线程池](#爬虫线程池)
  - [代理池](#代理池)
  - [缓存优化](#缓存优化)
  - [功能迭代记录](#功能迭代记录)
    - [2018.08.07](#20180807)
    - [2019.02.12](#20190212)
    - [2019.03.10](#20190310)
    - [2019.05.02](#20190502)
    - [2019.06.11](#20190611)
    - [2019.07.30](#20190730)
    - [2019.08.02](#20190802)
  - [2019.08.26](#20190826)
  - [2019.10.26](#20191026)
  - [2019.12.05](#20191205)
  - [2019.12.08](#20191208)
  - [2020.01.18](#20200118)
  - [2020.01.29](#20200129)
  - [2021.01.28](#20210128)

## 需求分析

> 虽然将项目冠以“框架”之名，但现在的目标仅仅是搭起框架的雏形，实现最基本的功能

- [x] 发送、接收HTTP请求（爬虫），暂时使用 HttpClient
- [x] HTTP连接池
- [x] 支持SSL
- [x] 爬虫任务池
- [x] 爬虫线程池
- [x] 使用临时文件优化下载时的内存占用
- [ ] 爬虫配置入口
- [ ] 爬虫生命周期管理
- [x] 利用Redis缓存请求（已实现，但效果很一般）
- [ ] 代理池
- [ ] 使用方便：更轻量的架构、更方便的配置
- [ ] 完善的监控、日志
- [ ] 可视化
- [x] 消息队列（Redis消息队列）
- [ ] 能否较通用地解决**登陆**问题？
- [ ] 提高稳定性，保持高可控
- [ ] 利用**分布式**提高效率
- [ ] 自动化**爬取**以及**获取结果**

## Http请求/响应的处理

目前以HTTPClient来实现HTTP连接、连接池与SSL，以后可能会用Netty去实现这些功能

## Http请求处理

对于爬虫任务，除了Http请求/响应本身外，还需要有增强功能，如缓存功能、输出详细日志功能、阻塞等待功能...这些功能模块有以下特点：

1. 作用于Http连接（请求+响应）的一个或多个具体阶段。
2. 各功能模块之间有顺序优先级。
3. 不同类型的任务可能拥有不同的功能模块。具体爬虫任务需要什么功能由使用者自定义。
4. 能控制爬虫任务的处理情况。

之前以**责任链模式**来设计功能模块，如图：

![error](Interceptor.JPG)

## 爬虫任务池

项目中的爬虫任务池，实际上就是爬虫任务的仓库。目前实现了基于Java阻塞队列的任务池与基于Redis消息队列的任务池，但后者主要只是尝试，并没有需求，基本不会使用。

### 爬虫任务池-基于Java阻塞队列的实现

这个实现就是项目最开始的目标，是在看了Hikari DataSource的数据库连接池后，刻意模仿的结果。

目前的实现，主要是通过两个集合管理爬虫任务，一个集合存放可用爬虫，一个集合存放已使用（出租）爬虫。除此之外，后面还增加了延期队列以实现延期处理功能。

对于可用爬虫的集合，采用了Map + BlockingQueue的结构。Map的键是爬虫任务的标识，值是BlockingQueue，BlockingQueue中按优先级顺序存放了爬虫任务。

已使用（出租）爬虫集合与延期队列，则是简单地用BlockingQueue实现。

---

目前采用由使用者主动交还的形式终止爬虫任务。但在任务池外，还使用了守护线程监视出租队列，定期移除无效任务。

---

通过一个守护线程维护延期队列：定期检测是否有任务结束延期，若有则将其返回可用队列。

目前通过延期队列实现对爬取频率的限制，即当任务限制了频率时，计算好执行时间然后交到延期队列中等待处理。相较于直接建立新子线程去处理（如等待后执行），这样统一调度的效率要高得多。

### 爬虫任务池-基于Redis消息队列的实现

该实现实际有用的场景，应该是分布式环境下多个服务器共同完成爬虫任务。目前并没有这个需求。而且对Redis的访问部份还很粗糙，只是写了一个RedisUtils用于获取lettuce的RedisClient。

## 爬虫线程池

项目中的爬虫线程池，最开始是自己手动实现的，后面改用Java的ThreadPoolExecutor线程池。

最开始的线程池，就是简单地将线程放在集合中，之后通过守护线程定期维护集合；后续换用Java线程池实现，但为了能越过线程池调用线程，还是在提交线程给线程池前，使用集合存储线程。

目前在使用线程池的过程中，还是直接操作了线程，导致线程池逻辑过于复杂，可以想办法替换掉对线程的操作。

## 代理池

除非付费购买，否则爬虫代理池的稳定性堪忧。大多数免费代理的有效期都很短，速度也很感人。除此之外，免费代理一般都没有restful API，需要手动爬取。

免费代理一般是透明代理，会加上特定请求头，使得被爬服务器可以知道使用了代理及真实IP。

## 缓存优化

## 功能迭代记录

### 2018.08.07

拖了这么久，终于要添加最麻烦的代理池功能了...

### 2019.02.12

这两天更新了项目，修正一些问题

### 2019.03.10

1. 项目存在的问题
   1. CrawlerContext过于开放（但如果因为开放而产生的修改而导致的问题，只能说问题自负吧 😶）
   2. 只能应用于HTTP协议 🐔
   3. 爬虫线程与控制器与处理器之间逻辑混乱，耦合严重
      1. 控制器没有起到调度的作用，反而是自己在处理逻辑

### 2019.05.02

1. 处理链机制
   1. 把拦截器与拦截器链解耦
      1. 拦截器链只有一个入口
         1. 每个拦截器会负责推进所拦截的操作的进度
            1. 采用**责任链模式**
2. 爬虫回收机制
3. 异常处理机制

### 2019.06.11

TODO: 优化代码结构、使用消息队列或其他技术提高爬虫池的内存性能、代理池优化、httpclient优化（可考虑用其他方式进行HTTP通信）

### 2019.07.30

补充下，之前实现对Redis的支持，利用Redis实现了缓存与消息队列两个模块，并优化了代码结构，使其更加合理

目前存在的问题是：

1. 对broti压缩的支持（HttpClient默认不支持）
2. 还没实现代理池
3. 配置类、配置流程仍需简化
4. 缺少注释

### 2019.08.02

- [ ] 可能需要有一种方式，可以在在各个处理器间传递参数
- [ ] 需要能自定义构建key的逻辑

## 2019.08.26

- [x] 将文件直接存到内存中，会导致内存占用过大。应考虑将文件存在本地磁盘中，作为临时文件。
- [ ] 实体的类型是文件时，缓存的处理方式需要升级

## 2019.10.26

- [x] 把配置由写死优化为读配置文件，以避免重复配置与分享代码导致的账号泄露问题

## 2019.12.05

考虑如何实现定时同步konachan收藏夹。可以考虑用系统级的定时任务，定时执行爬虫任务来实现。

## 2019.12.08

发现问题：对于各监听器，当运行在其他服务器上，而不是一次性执行时，不会被回收，并且仍会定时运行。。。

对于这个问题，一个是可以考虑实现单例，一个是可以考虑在结束任务时也结束各守护线程。目前先考虑实现后者，为此，需要先改变原本随意启动监听器的局面，考虑把所有监听器都交由controller进行管理。

## 2020.01.18

能否实现监控下载的具体进度（如百分比）？

## 2020.01.29

现在实现的只是多任务爬虫，无法引用于下载单个大文件的场景

## 2021.01.28

- 完善文档，整理思路

## 2021.12.11

实现由一个线程强制中断另一个线程正在执行的任务的功能。原本只能由执行任务的线程自己中断任务。

思路：

- 无法强制结束线程
- 必须明确强制中断的流程
- 进入强制中断的流程的方式：
  - 线程执行过程中报错（难以控制）
  - 通过状态判断（非执行线程只改变任务状态，由执行线程自己根据状态进入中断流程）
    - 可以在状态切换时判断
    - 可以在特定行为时判断
- 非执行线程需要尝试主动调用执行线程的interrupt()方法结束其阻塞或睡眠

问题在于，似乎无法通过中断线程的方式来中断目前的数据传输。似乎可以尝试修改传输数据的方法，自己实现可中断的逻辑。

